# Copyright 2020 Linus S. (aka PistonMiner)

import sys
import os
import re

def parse_map(file, parse_function):
	current_section = "none"
	for line in file:
		# Find section layout section of the file, there should only be the memory map after this
		if "Link map of __start" in line:
			current_section = "link_map"
			continue
		elif " section layout" in line:
			current_section = "section_layouts"
			continue
		elif "Memory map:" in line:
			current_section = "memory_map"
			continue

		#print("Mode: {}".format(current_section))

		if line.lstrip().rstrip() == "":
			print("Skipping empty line")
			continue

		#print("Line: {}".format(line))
		parse_function(line, current_section)

def main():
	if len(sys.argv) != 4:
		print("Usage: {} <address map> <link map> <out lst>".format(sys.argv[0]))
		return

	symbols = []
	symbol_addresses = {}
	symbol_affiliations = {}

	def parse_link_map(line, current_section):
		if current_section == "link_map":
			if ">>>" in line:
				print("Skipping special line")
				return

			m = re.match(
				r"\s*(\d+)] ([@0-9A-z_.$]+) \(([a-z]+),([a-z]+)\) found in ([0-9A-z_.\s]+)",
				line.rstrip().lstrip()
			)
			if m == None:
				print("RE mismatch: {}".format(line.rstrip()))
				return

			tokens = m.groups()
			#print(tokens)
			level = int(tokens[0])
			symbol_name = tokens[1]
			symbol_type = tokens[2]
			symbol_scope = tokens[3]
			symbol_namespace = tokens[4]

			symbol_id = (symbol_name, symbol_namespace)
			symbol_affiliation = {
				"type": symbol_type,
				"scope": symbol_scope
			}
			if symbol_id in symbol_affiliations:
				print("Symbol duplication: {} - {}".format(symbol_id, symbol_affiliation))
			symbol_affiliations[symbol_id] = symbol_affiliation

	def parse_section_layout(line, current_section):
		if current_section == "section_layouts":
			if len(line) <= 30:
				#print("Removing line for length <= 30")
				return
			tokens = re.split("[ \t]", line.rstrip().lstrip())
			if len(tokens) < 5:
				#print("Removing line for tokens < 5 ({})".format(len(tokens)))
				return

			if "UNUSED" in tokens and "........" in tokens:
				#print("Removing line for unused symbol")
				return

			while "" in tokens:
				tokens.remove("")

			address = int(tokens[2], 16)
			name = tokens[4]
			namespace = " ".join(tokens[5:])

			# Skip anonymous symbols and subsection symbols
			if name.startswith("@") or name.startswith(".") or name.startswith("(entry"):
				return

			symbol_id = (name, namespace)
			symbol_addresses[symbol_id] = address

	with open(sys.argv[1], "r") as map_file:
		parse_map(map_file, parse_section_layout)

	with open(sys.argv[2], "r") as map_file:
		parse_map(map_file, parse_link_map)

	# Attach affiliations
	symbols = []
	for symbol_id, symbol_address in symbol_addresses.items():
		symbol_name, symbol_namespace = symbol_id

		if symbol_id in symbol_affiliations:
			symbol_affiliation = symbol_affiliations[symbol_id]
		else:
			symbol_affiliation = {
				"type": "unknown",
				"scope": "unknown"
			}
		symbol_type = symbol_affiliation["type"]
		symbol_scope = symbol_affiliation["scope"]
		symbols.append({
			"name": symbol_name,
			"namespace": symbol_namespace,
			"address": symbol_address,
			"type": symbol_type,
			"scope": symbol_scope
		})
	symbols.sort(key=lambda x: x["address"])

	output_type = "elf2rel"
	with open(sys.argv[3], "w") as output_file:
		if output_type == "csv":
			output_file.write("name,namespace,address,type,scope\n")
			for symbol in symbols:
				line = "{},{},{:08x},{},{}\n".format(
					symbol["name"],
					symbol["namespace"],
					symbol["address"],
					symbol["type"],
					symbol["scope"]
				)
				output_file.write(line)
		elif output_type == "elf2rel":
			output_file.write("// Autogenerated file\n\n")
			current_namespace = None
			is_unknown = False
			for symbol in symbols:
				new_namespace = symbol["namespace"]

				if new_namespace != "" and new_namespace != current_namespace:
					# New, real namespace
					if current_namespace != None:
						output_file.write("\n")

					# If we were unknown, now we're not
					is_unknown = False

					current_namespace = new_namespace

					output_file.write("// {}\n".format(symbol["namespace"]))
				elif new_namespace == "" and not is_unknown:
					# Unknown namespace, first entry
					if current_namespace != None:
						output_file.write("\n")

					is_unknown = True
				elif new_namespace == current_namespace and is_unknown:
					# Same real namespace as we were in
					output_file.write("\n")
					is_unknown = False

				output_file.write(
					"{}{:08x}:{}\n".format(
						"// " if symbol["scope"] == "local" else "",
						symbol["address"],
						symbol["name"]
					)
				)
		else:
			assert(False)

if __name__ == "__main__":
	main()